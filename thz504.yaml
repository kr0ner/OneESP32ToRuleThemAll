#########################################
#                                       #
#   Obtain initial states               #
#                                       #
#########################################
esphome:
  on_boot:
    priority: -100
    then:
      - lambda: |-
          queueRequest(Kessel, Property::kLUEFT_STUFE_TAG);
          queueRequest(Kessel, Property::kLUEFT_STUFE_NACHT);
          queueRequest(Kessel, Property::kLUEFT_STUFE_PARTY);
          queueRequest(Kessel, Property::kPROGRAMMSCHALTER);
          queueRequest(Kessel, Property::kEL_AUFNAHMELEISTUNG_WW_TAG_WH);
          queueRequest(Kessel, Property::kEL_AUFNAHMELEISTUNG_WW_TAG_KWH);
          queueRequest(Kessel, Property::kEL_AUFNAHMELEISTUNG_HEIZ_TAG_WH);
          queueRequest(Kessel, Property::kEL_AUFNAHMELEISTUNG_HEIZ_TAG_KWH);

#########################################
#                                       #
#   Global variables                    #
#                                       #
#########################################
globals:
  - id: gEL_AUFNAHMELEISTUNG_WW_TAG_WH
    type: int
    initial_value: '0'
  - id: gEL_AUFNAHMELEISTUNG_HEIZ_TAG_WH
    type: int
    initial_value: '0'

#########################################
#                                       #
#   SPI configuration                   #
#                                       #
#########################################
spi:
  id: McpSpi
  clk_pin: GPIO14
  mosi_pin: GPIO13
  miso_pin: GPIO4

#########################################
#                                       #
#   EVU Sperre                          #
#                                       #
#########################################
switch:
  - platform: gpio
    name: "EVU Sperre"
    id: evu_sperre
    pin: GPIO5

#########################################
#                                       #
#   Binary Sensors                      #
#                                       #
#########################################
binary_sensor:
#########################################
#                                       #
#   Kondensatpumpe Störung              #
#                                       #
#########################################
  - platform: gpio
    pin: 
      number: GPIO32
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Kondensatpumpe Störung"
    filters:
      - delayed_on: 1s
      - delayed_off: 1min
    on_press:
      then:
        - switch.turn_on: evu_sperre
    on_release:
      then:
        - switch.turn_off: evu_sperre

#########################################
#                                       #
#   Betriebstatus Sensors               #
#                                       #
#########################################
  - platform: template
    name: "SCHALTPROGRAMM_AKTIV"
    id: SCHALTPROGRAMM_AKTIV

  - platform: template
    name: "VERDICHTER"
    id: VERDICHTER

  - platform: template
    name: "HEIZEN"
    id: HEIZEN

  - platform: template
    name: "KUEHLEN"
    id: KUEHLEN

  - platform: template
    name: "WARMWASSERBEREITUNG"
    id: WARMWASSERBEREITUNG

  - platform: template
    name: "ELEKTRISCHE_NACHERWAERMUNG"
    id: ELEKTRISCHE_NACHERWAERMUNG

  - platform: template
    name: "SERVICE"
    id: SERVICE

  - platform: template
    name: "EVU_SPERRE"
    id: EVU_SPERRE

  - platform: template
    name: "FILTERWECHSEL_BEIDE"
    id: FILTERWECHSEL_BEIDE

  - platform: template
    name: "LUEFTUNG"
    id: LUEFTUNG

  - platform: template
    name: "HEIZKREISPUMPE"
    id: HEIZKREISPUMPE

  - platform: template
    name: "ABTAUEN_VERDAMPFER"
    id: ABTAUEN_VERDAMPFER

  - platform: template
    name: "FILTERWECHSEL_ABLUFT"
    id: FILTERWECHSEL_ABLUFT

  - platform: template
    name: "FILTERWECHSEL_ZULUFT"
    id: FILTERWECHSEL_ZULUFT

  - platform: template
    name: "AUFHEIZPROGRAMM_AKTIV"
    id: AUFHEIZPROGRAMM_AKTIV

#########################################
#                                       #
#   intervals                           #
#                                       #
#########################################
interval:
  - interval: 1sec
    then:
      - lambda: |-
          // Request sensor value one after another. This prevents warnings like "Component canbus took a long time for an operation"
          if(!request_queue.empty()) {
            constexpr auto use_extended_id{false};
            const auto request_element = request_queue.front();
            request_queue.pop();
            requestData(request_element.first, request_element.second);
          }

#########################################
#                                       #
#   time triggers                       #
#                                       #
#########################################
time:
  - platform: sntp
    on_time:
      # Every hour except midnight. Helper will be set when the response is received
      - seconds: 0
        minutes: 0
        hours: 1-23
        then:
          - lambda: |-
              queueRequest(Kessel, Property::kEL_AUFNAHMELEISTUNG_WW_TAG_WH);
              queueRequest(Kessel, Property::kEL_AUFNAHMELEISTUNG_WW_TAG_KWH);
              queueRequest(Kessel, Property::kEL_AUFNAHMELEISTUNG_HEIZ_TAG_WH);
              queueRequest(Kessel, Property::kEL_AUFNAHMELEISTUNG_HEIZ_TAG_KWH);
      # At midnight reset power consumptions. The helper must not be set!
      - seconds: 0
        minutes: 0
        hours: 0
        then:
          - sensor.template.publish:
              id: EL_AUFNAHMELEISTUNG_WW_TAG_WH
              state: 0.0
          - sensor.template.publish:
              id: EL_AUFNAHMELEISTUNG_WW_SUMME_KWH
              state: 0.0
          - sensor.template.publish:
              id: EL_AUFNAHMELEISTUNG_HEIZ_TAG_WH
              state: 0.0
          - sensor.template.publish:
              id: EL_AUFNAHMELEISTUNG_HEIZ_SUMME_KWH
              state: 0.0

#########################################
#                                       #
#   packages                            #
#                                       #
#########################################
packages:
  WAERMEERTRAG_RUECKGE_SUMME_KWH: !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_RUECKGE_SUMME_KWH", unit: "kWh" }}
  WAERMEERTRAG_RUECKGE_TAG_WH:    !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_RUECKGE_TAG_WH"   , unit: "Wh"  }}
  WAERMEERTRAG_RUECKGE_TAG_KWH:   !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_RUECKGE_TAG_KWH"  , unit: "kWh" }}
  WAERMEERTRAG_2WE_WW_SUM_KWH:    !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_2WE_WW_SUM_KWH"   , unit: "kWh" }}
  WAERMEERTRAG_2WE_WW_SUM_MWH:    !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_2WE_WW_SUM_MWH"   , unit: "MWh" }}
  WAERMEERTRAG_2WE_HEIZ_TAG_WH:   !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_2WE_HEIZ_TAG_WH"  , unit: "Wh"  }}
  WAERMEERTRAG_2WE_HEIZ_TAG_KWH:  !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_2WE_HEIZ_TAG_KWH" , unit: "kWh" }}
  WAERMEERTRAG_2WE_HEIZ_SUM_KWH:  !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_2WE_HEIZ_SUM_KWH" , unit: "kWh" }}
  WAERMEERTRAG_2WE_HEIZ_SUM_MWH:  !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_2WE_HEIZ_SUM_MWH" , unit: "MWh" }}
  WAERMEERTRAG_WW_TAG_WH:         !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_WW_TAG_WH"        , unit: "Wh"  }}
  WAERMEERTRAG_WW_TAG_KWH:        !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_WW_TAG_KWH"       , unit: "kWh" }}
  WAERMEERTRAG_WW_SUM_KWH:        !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_WW_SUM_KWH"       , unit: "kWh" }}
  WAERMEERTRAG_WW_SUM_MWH:        !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_WW_SUM_MWH"       , unit: "kWh" }}
  WAERMEERTRAG_HEIZ_TAG_WH:       !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_HEIZ_TAG_WH"      , unit: "Wh"  }}
  WAERMEERTRAG_HEIZ_TAG_KWH:      !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_HEIZ_TAG_KWH"     , unit: "kWh" }}
  WAERMEERTRAG_HEIZ_SUM_KWH:      !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_HEIZ_SUM_KWH"     , unit: "kWh" }}
  WAERMEERTRAG_HEIZ_SUM_MWH:      !include { file: thz504_energy.yaml, vars: { property: "WAERMEERTRAG_HEIZ_SUM_MWH"     , unit: "MWh" }}

  # SOLL values are always actively changed and transmitted, so we just need to limit the update interval
  SPEICHERSOLLTEMP:               !include { file: thz504_temperature_throttled.yaml, vars: { property: "SPEICHERSOLLTEMP"         , target: "Kessel"   , interval: $interval_very_slow, delta: 1.0 }}
  VERSTELLTE_RAUMSOLLTEMP:        !include { file: thz504_temperature_throttled.yaml, vars: { property: "VERSTELLTE_RAUMSOLLTEMP"  , target: "HK1"      , interval: $interval_very_slow, delta: 1.0 }}
  RAUMSOLLTEMP_I:                 !include { file: thz504_temperature_throttled.yaml, vars: { property: "RAUMSOLLTEMP_I"           , target: "HK1"      , interval: $interval_very_slow, delta: 1.0 }}
  EINSTELL_SPEICHERSOLLTEMP:      !include { file: thz504_temperature_throttled.yaml, vars: { property: "EINSTELL_SPEICHERSOLLTEMP", target: "Kessel"   , interval: $interval_very_slow, delta: 1.0 }}

  # IST values can change at any time, but we want to limit the updates to not flood the database. Still update if delta is too big.
  RAUMISTTEMP:                    !include { file: thz504_temperature_polled_throttled.yaml, vars: { property: "RAUMISTTEMP"    ,   target: "HK1",     interval: $interval_very_slow, delta: 1.0 }}
  SPEICHERISTTEMP:                !include { file: thz504_temperature_polled_throttled.yaml, vars: { property: "SPEICHERISTTEMP",   target: "Kessel" , interval: $interval_very_slow, delta: 1.0 }}
  AUSSENTEMP:                     !include { file: thz504_temperature_polled_throttled.yaml, vars: { property: "AUSSENTEMP"     ,   target: "Kessel" , interval: $interval_very_slow, delta: 1.0 }}
  SAMMLERISTTEMP:                 !include { file: thz504_temperature_polled_throttled.yaml, vars: { property: "SAMMLERISTTEMP" ,   target: "Kessel" , interval: $interval_very_slow, delta: 1.0 }}
  VERDAMPFERTEMP:                 !include { file: thz504_temperature_polled_throttled.yaml, vars: { property: "VERDAMPFERTEMP" ,   target: "Kessel" , interval: $interval_very_slow, delta: 1.0 }}
  RUECKLAUFISTTEMP:               !include { file: thz504_temperature_polled_throttled.yaml, vars: { property: "RUECKLAUFISTTEMP" , target: "Kessel" , interval: $interval_very_slow, delta: 1.0 }}

  LUEFT_STUFE_TAG:                !include { file: thz504_ventilation.yaml, vars: { property: "LUEFT_STUFE_TAG"   }}
  LUEFT_STUFE_NACHT:              !include { file: thz504_ventilation.yaml, vars: { property: "LUEFT_STUFE_NACHT" }}
  LUEFT_STUFE_PARTY:              !include { file: thz504_ventilation.yaml, vars: { property: "LUEFT_STUFE_PARTY" }}
# Remove once https://github.com/esphome/issues/issues/5541 is fixed
# This is needed to prevent missing headers for SpeedFan component
output:
  - platform: gpio
    pin: GPIO16 # is anyways not connected
    id: dummy_gpio

#########################################
#                                       #
#   sensors                             #
#                                       #
#########################################
sensor:
  - platform: template
    name: "FEHLERMELDUNG"
    id: FEHLERMELDUNG
    icon: "mdi:alert-circle"
    accuracy_decimals: 0

  - platform: template
    name: "JAHR"
    id: JAHR
    icon: "mdi:calendar"
    accuracy_decimals: 0

  - platform: template
    name: "MONAT"
    id: MONAT
    icon: "mdi:calendar"
    accuracy_decimals: 0

  - platform: template
    name: "WOCHENTAG"
    id: WOCHENTAG
    icon: "mdi:calendar-today"
    accuracy_decimals: 0

  - platform: template
    name: "TAG"
    id: TAG
    icon: "mdi:calendar-today"
    accuracy_decimals: 0

  - platform: template
    name: "STUNDE"
    id: STUNDE
    icon: "mdi:calendar-clock"
    accuracy_decimals: 0

  - platform: template
    name: "MINUTE"
    id: MINUTE
    icon: "mdi:calendar-clock"
    accuracy_decimals: 0

  - platform: template
    name: "ABLUFT_IST"
    id: ABLUFT_IST
    unit_of_measurement: "l/min"
    icon: "mdi:fan"
    state_class: "measurement"
    accuracy_decimals: 0
    update_interval: $interval_medium
    filters:
      - or:
        - throttle: $interval_medium
        - delta: 10%
    lambda: |-
      queueRequest(Kessel, Property::kABLUFT_IST);
      return {};

  - platform: template
    name: "FORTLUFT_SOLL"
    id: FORTLUFT_SOLL
    unit_of_measurement: "l/min"
    icon: "mdi:fan"
    state_class: "measurement"
    accuracy_decimals: 0
    update_interval: $interval_medium
    lambda: |-
      queueRequest(Kessel, Property::kFORTLUFT_SOLL);
      return {};

  - platform: template
    name: "FORTLUFT_IST"
    id: FORTLUFT_IST
    unit_of_measurement: "l/min"
    icon: "mdi:fan"
    state_class: "measurement"
    accuracy_decimals: 0
    update_interval: $interval_medium
    filters:
      - or:
        - throttle: $interval_medium
        - delta: 10%
    lambda: |-
      queueRequest(Kessel, Property::kFORTLUFT_IST);
      return {};

  - platform: template
    name: "ANZEIGE_NIEDERDRUCK"
    id: ANZEIGE_NIEDERDRUCK
    accuracy_decimals: 2

  - platform: template
    name: "PUMPENZYKLEN_MIN_AUSSENT"
    id: PUMPENZYKLEN_MIN_AUSSENT
    accuracy_decimals: 0

  - platform: template
    name: "VOLUMENSTROM"
    id: VOLUMENSTROM
    unit_of_measurement: "l/min"
    icon: "mdi:pump"
    device_class: "volume"
    state_class: "measurement"
    accuracy_decimals: 1
    update_interval: $interval_very_slow
    filters:
      - or:
        - throttle: $interval_very_slow
        - delta: 1.0
    lambda: |-
      queueRequest(Kessel, Property::kVOLUMENSTROM);
      return {};

  - platform: template
    name: "ABLUFT_SOLL"
    id: ABLUFT_SOLL
    unit_of_measurement: "l/min"
    icon: "mdi:fan"
    state_class: "measurement"
    accuracy_decimals: 0
    update_interval: $interval_slow
    lambda: |-
      queueRequest(Kessel, Property::kABLUFT_SOLL);
      return {};

  - platform: template
    name: "ZULUFT_IST"
    id: ZULUFT_IST
    unit_of_measurement: "l/min"
    icon: "mdi:fan"
    state_class: "measurement"
    accuracy_decimals: 0
    update_interval: $interval_slow
    filters:
      - throttle: $interval_slow
    lambda: |-
      queueRequest(Kessel, Property::kZULUFT_IST);
      return {};

  - platform: homeassistant
    name: "Temperature Sensor From Home Assistant"
    entity_id: sensor.durchschnittstemperatur_haus
    filters:
      - throttle: $interval_slow
    on_value:
      then:
        - lambda: |-
            ESP_LOGI("SET", "Avg temperature set to %f", x);
            sendData(HK1, Property::kRAUMISTTEMP, static_cast<std::uint16_t>(x * 10));

  - platform: template
    name: "EL_AUFNAHMELEISTUNG_WW_TAG_WH"
    id: EL_AUFNAHMELEISTUNG_WW_TAG_WH
    unit_of_measurement: "Wh"
    icon: "mdi:power"
    state_class: "measurement"
    accuracy_decimals: 0
    internal: true

  - platform: template
    name: "EL_AUFNAHMELEISTUNG_WW_SUMME_KWH"
    id: EL_AUFNAHMELEISTUNG_WW_SUMME_KWH
    unit_of_measurement: "kWh"
    icon: "mdi:power"
    accuracy_decimals: 2
    device_class: energy
    state_class: total_increasing

  - platform: template
    name: "EL_AUFNAHMELEISTUNG_HEIZ_TAG_WH"
    id: EL_AUFNAHMELEISTUNG_HEIZ_TAG_WH
    unit_of_measurement: "Wh"
    icon: "mdi:power"
    state_class: "measurement"
    accuracy_decimals: 0
    internal: true

  - platform: template
    name: "EL_AUFNAHMELEISTUNG_HEIZ_SUMME_KWH"
    id: EL_AUFNAHMELEISTUNG_HEIZ_SUMME_KWH
    unit_of_measurement: "kWh"
    icon: "mdi:power"
    accuracy_decimals: 2
    state_class: total_increasing
    device_class: energy

#########################################
#                                       #
#   selects                             #
#                                       #
#########################################
select:
  - platform: template
    name: "PROGRAMMSCHALTER"
    id: PROGRAMMSCHALTER
    options:
      - "Notbetrieb"
      - "Bereitschaft"
      - "Automatik"
      - "Tagbetrieb"
      - "Absenkbetrieb"
      - "Warmwasser"
      - "Handbetrieb"
      - "Unbekannt"
    initial_option: "Unbekannt"
    optimistic: true
    setup_priority: 100
    on_value:
      then:
        - lambda: |-
            const auto it = std::find_if(BetriebsartMappings.begin(), BetriebsartMappings.end(), 
              [x](const BetriebsartMapping& mapping){
              return (x == std::string(mapping.name) && x != "Unbekannt");
            });
            if(it != BetriebsartMappings.end() && id(PROGRAMMSCHALTER).state != x) {
              sendData(Kessel, Property::kPROGRAMMSCHALTER, it->id);
            }

#########################################
#                                       #
#   Wärmepumpe climates                 #
#                                       #
#########################################
climate:
  - platform: custom
    lambda: |-
      auto heating = new HeatingDay(id(RAUMISTTEMP),id(VERSTELLTE_RAUMSOLLTEMP));
      App.register_component(heating);
      return {heating};
    climates:
      - name: "Heating Day"

  - platform: custom
    lambda: |-
      auto heating = new HeatingNight(id(RAUMISTTEMP),id(VERSTELLTE_RAUMSOLLTEMP));
      App.register_component(heating);
      return {heating};
    climates:
      - name: "Heating Night"

  - platform: custom
    lambda: |-
      auto hot_water = new HotWater(id(SPEICHERISTTEMP),id(EINSTELL_SPEICHERSOLLTEMP));
      App.register_component(hot_water);
      return {hot_water};
    climates:
      - name: "HotWater"

#########################################
#                                       #
#   CANbus configuration                #
#                                       #
#########################################
canbus:
  - platform: mcp2515
    id: my_mcp2515
    spi_id: McpSpi
    cs_pin: GPIO15
    can_id: 680
    use_extended_id: false
    bit_rate: 20kbps
    on_frame:

#########################################
#                                       #
#   KESSEL messages                     #
#                                       #
#########################################
    - can_id: 0x180
      then:
        - lambda: |-
            const auto property_value_pair = processCanMessage(x);
            Property property{property_value_pair.first};
            SimpleVariant value{property_value_pair.second};

            switch(property) {
              case Property::kFEHLERMELDUNG:
                id(FEHLERMELDUNG).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kAUSSENTEMP:
                id(AUSSENTEMP).publish_state(value.get<float>());
                break;
              case Property::kSAMMLERISTTEMP:
                id(SAMMLERISTTEMP).publish_state(value.get<float>());
                break;
              case Property::kVERDAMPFERTEMP:
                id(VERDAMPFERTEMP).publish_state(value.get<float>());
                break;
              case Property::kRUECKLAUFISTTEMP:
                id(RUECKLAUFISTTEMP).publish_state(value.get<float>());
                break;
              case Property::kPROGRAMMSCHALTER:
                {
                  const auto index = id(PROGRAMMSCHALTER).index_of(value.get<std::string>());
                  if(index.has_value()) {
                    id(PROGRAMMSCHALTER).publish_state(value.get<std::string>());
                  }
                  break;
                }
              case Property::kWOCHENTAG:
                id(WOCHENTAG).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kTAG:
                id(TAG).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kMONAT:
                id(MONAT).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kJAHR:
                id(JAHR).publish_state(value.get<std::uint16_t>() + 2000U);
                break;
              case Property::kSTUNDE:
                id(STUNDE).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kMINUTE:
                id(MINUTE).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kBETRIEBS_STATUS:
                {
                  const std::bitset<15U> status_bits{value.get<std::uint16_t>()};
                  id(SCHALTPROGRAMM_AKTIV).publish_state(status_bits.test(0U));
                  id(VERDICHTER).publish_state(status_bits.test(1U));
                  id(HEIZEN).publish_state(status_bits.test(2U));
                  id(KUEHLEN).publish_state(status_bits.test(3U));
                  id(WARMWASSERBEREITUNG).publish_state(status_bits.test(4U));
                  id(ELEKTRISCHE_NACHERWAERMUNG).publish_state(status_bits.test(5U));
                  id(SERVICE).publish_state(status_bits.test(6U));
                  id(EVU_SPERRE).publish_state(status_bits.test(7U));
                  id(FILTERWECHSEL_BEIDE).publish_state(status_bits.test(8U));
                  id(LUEFTUNG).publish_state(status_bits.test(9U));
                  id(HEIZKREISPUMPE).publish_state(status_bits.test(10U));
                  id(ABTAUEN_VERDAMPFER).publish_state(status_bits.test(11U));
                  id(FILTERWECHSEL_ABLUFT).publish_state(status_bits.test(12U));
                  id(FILTERWECHSEL_ZULUFT).publish_state(status_bits.test(13U));
                  id(AUFHEIZPROGRAMM_AKTIV).publish_state(status_bits.test(14U));
                  break;
                }
              case Property::kABLUFT_IST:
                id(ABLUFT_IST).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kFORTLUFT_SOLL:
                id(FORTLUFT_SOLL).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kFORTLUFT_IST:
                id(FORTLUFT_IST).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kANZEIGE_NIEDERDRUCK:
                id(ANZEIGE_NIEDERDRUCK).publish_state(value.get<float>());
                break;
              case Property::kVOLUMENSTROM:
                id(VOLUMENSTROM).publish_state(value.get<float>());
                break;
              case Property::kSPEICHERSOLLTEMP:
                id(SPEICHERSOLLTEMP).publish_state(value.get<float>());
                break;
              case Property::kABLUFT_SOLL:
                id(ABLUFT_SOLL).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kZULUFT_IST:
                id(ZULUFT_IST).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_RUECKGE_SUMME_KWH:
                id(WAERMEERTRAG_RUECKGE_SUMME_KWH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_RUECKGE_TAG_WH:
                id(WAERMEERTRAG_RUECKGE_TAG_WH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_RUECKGE_TAG_KWH:
                id(WAERMEERTRAG_RUECKGE_TAG_KWH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_2WE_WW_SUM_KWH:
                id(WAERMEERTRAG_2WE_WW_SUM_KWH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_2WE_WW_SUM_MWH:
                id(WAERMEERTRAG_2WE_WW_SUM_MWH).publish_state(value.get<double>());
                break;
              case Property::kWAERMEERTRAG_2WE_HEIZ_TAG_WH:
                id(WAERMEERTRAG_2WE_HEIZ_TAG_WH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_2WE_HEIZ_TAG_KWH:
                id(WAERMEERTRAG_2WE_HEIZ_TAG_KWH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_2WE_HEIZ_SUM_KWH:
                id(WAERMEERTRAG_2WE_HEIZ_SUM_KWH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_2WE_HEIZ_SUM_MWH:
                id(WAERMEERTRAG_2WE_HEIZ_SUM_MWH).publish_state(value.get<double>());
                break;
              case Property::kWAERMEERTRAG_WW_TAG_WH:
                id(WAERMEERTRAG_WW_TAG_WH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_WW_TAG_KWH:
                id(WAERMEERTRAG_WW_TAG_KWH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_WW_SUM_KWH:
                id(WAERMEERTRAG_WW_SUM_KWH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_WW_SUM_MWH:
                id(WAERMEERTRAG_WW_SUM_MWH).publish_state(value.get<double>());
                break;
              case Property::kWAERMEERTRAG_HEIZ_TAG_WH:
                id(WAERMEERTRAG_HEIZ_TAG_WH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_HEIZ_TAG_KWH:
                id(WAERMEERTRAG_HEIZ_TAG_KWH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_HEIZ_SUM_KWH:
                id(WAERMEERTRAG_HEIZ_SUM_KWH).publish_state(value.get<std::uint16_t>());
                break;
              case Property::kWAERMEERTRAG_HEIZ_SUM_MWH:
                id(WAERMEERTRAG_HEIZ_SUM_MWH).publish_state(value.get<double>());
                break;
              case Property::kSPEICHERISTTEMP:
                id(SPEICHERISTTEMP).publish_state(value.get<float>());
                break;
              case Property::kEINSTELL_SPEICHERSOLLTEMP:
                id(EINSTELL_SPEICHERSOLLTEMP).publish_state(value.get<float>());
                break;
              case Property::kLUEFT_STUFE_PARTY:
                {
                  const auto fan_speed = std::min(static_cast<std::uint16_t>(3U),value.get<std::uint16_t>());
                  auto call = (fan_speed == 0U) ? id(LUEFT_STUFE_PARTY).turn_off() : id(LUEFT_STUFE_PARTY).turn_on();
                  call.set_speed(fan_speed);
                  call.perform();
                  break;
                }
              case Property::kLUEFT_STUFE_TAG:
                {
                  const auto fan_speed = std::min(static_cast<std::uint16_t>(3U),value.get<std::uint16_t>());
                  auto call = (fan_speed == 0U) ? id(LUEFT_STUFE_TAG).turn_off() : id(LUEFT_STUFE_TAG).turn_on();
                  call.set_speed(fan_speed);
                  call.perform();
                  break;
                }
              case Property::kLUEFT_STUFE_NACHT:
                {
                  const auto fan_speed = std::min(static_cast<std::uint16_t>(3U),value.get<std::uint16_t>());
                  auto call = (fan_speed == 0U) ? id(LUEFT_STUFE_NACHT).turn_off() : id(LUEFT_STUFE_NACHT).turn_on();
                  call.set_speed(fan_speed);
                  call.perform();
                  break;
                }
              case Property::kEL_AUFNAHMELEISTUNG_HEIZ_TAG_WH:
                {
                  // This value is not reset after midnight, messing up the Energy Dashboard
                  // We manually set the sensor value to zero at midnight (see above) and ignore
                  // the stale sensor value until we get a proper reading.
                  const auto new_value = value.get<std::uint16_t>();
                  if(new_value != id(gEL_AUFNAHMELEISTUNG_HEIZ_TAG_WH)) {
                    // Set the actual sensor value
                    id(EL_AUFNAHMELEISTUNG_HEIZ_TAG_WH).publish_state(new_value);
                    // Set the helper
                    id(gEL_AUFNAHMELEISTUNG_HEIZ_TAG_WH) = new_value;
                  }
                  break;
                }
              case Property::kEL_AUFNAHMELEISTUNG_HEIZ_TAG_KWH:
                id(EL_AUFNAHMELEISTUNG_HEIZ_SUMME_KWH).publish_state(value.get<double>() + (0.001*id(gEL_AUFNAHMELEISTUNG_HEIZ_TAG_WH)));
                break;
              case Property::kEL_AUFNAHMELEISTUNG_WW_TAG_WH:
                {
                  // This value is not reset after midnight, messing up the Energy Dashboard
                  // We manually set the sensor value to zero at midnight (see above) and ignore
                  // the stale sensor value until we get a proper reading.
                  const auto new_value = value.get<std::uint16_t>();
                  if(new_value != id(gEL_AUFNAHMELEISTUNG_WW_TAG_WH)) {
                    // Set the actual sensor value
                    id(EL_AUFNAHMELEISTUNG_WW_TAG_WH).publish_state(new_value);
                    // Set the helper
                    id(gEL_AUFNAHMELEISTUNG_WW_TAG_WH) = new_value;
                  }
                  break;
                }
              case Property::kEL_AUFNAHMELEISTUNG_WW_TAG_KWH:
                id(EL_AUFNAHMELEISTUNG_WW_SUMME_KWH).publish_state(value.get<double>() + (0.001*id(gEL_AUFNAHMELEISTUNG_WW_TAG_WH)));
                break;
              case 0x064a: //druck heizkreis /10
              default:
                ESP_LOGI("custom","[Kessel] Unhandled Id %04x", property);
            }

#########################################
#                                       #
#   HK1 messages                        #
#                                       #
#########################################
    - can_id: 0x301
      then:
        - lambda: |-
            const auto property_value_pair = processCanMessage(x);
            Property property{property_value_pair.first};
            SimpleVariant value{property_value_pair.second};

            switch(property) {
              case Property::kRAUMSOLLTEMP_I:
                id(RAUMSOLLTEMP_I).publish_state(value.get<float>());
                break;
              case Property::kVERSTELLTE_RAUMSOLLTEMP:
                id(VERSTELLTE_RAUMSOLLTEMP).publish_state(value.get<float>());
                break;
              case Property::kRAUMISTTEMP:
                id(RAUMISTTEMP).publish_state(value.get<float>());
                break;
              case Property::kVORLAUFISTTEMP:
              case Property::kVORLAUFSOLLTEMP:
              case Property::kFEUCHTE:
              default:
                ESP_LOGI("custom","[HK1] Unhandled Id %04x", property);
            }

#########################################
#                                       #
#   HK2 messages                        #
#                                       #
#########################################
    - can_id: 0x302
      then:
        - lambda: |-
            const auto property_value_pair = processCanMessage(x);
            Property property{property_value_pair.first};
            SimpleVariant value{property_value_pair.second};

            switch(property) {
              case Property::kRAUMISTTEMP:
              case Property::kVORLAUFISTTEMP:
              case Property::kVORLAUFSOLLTEMP:
              case Property::kVERSTELLTE_RAUMSOLLTEMP:
              case Property::kFEUCHTE:
                break;
              default:
                ESP_LOGI("custom","[HK2] Unhandled Id %04x", property);
            }

#########################################
#                                       #
#   Message requests                    #
#                                       #
#########################################
    - can_id: 0x6a1
      then:
        - lambda: |-
            const auto property_value_pair = processCanMessage(x);
            Property property{property_value_pair.first};
            SimpleVariant value{property_value_pair.second};

            switch(property) {
              default:
                ESP_LOGD("custom","Unhandled id %04x requested", property);
            }
